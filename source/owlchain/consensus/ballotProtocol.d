module owlchain.consensus.ballotProtocol;

import std.stdio;
import std.container;
import std.conv;
import std.json;
import std.algorithm: canFind;
import std.algorithm : find;
import std.typecons;
import std.digest.sha;
import core.stdc.stdint;

import owlchain.xdr.type;
import owlchain.xdr.statement;
import owlchain.xdr.statementType;
import owlchain.xdr.hash;
import owlchain.xdr.envelope;
import owlchain.xdr.value;
import owlchain.xdr.quorumSet;
import owlchain.xdr.nodeID;
import owlchain.xdr.ballot;

import owlchain.consensus.consensusProtocol;
import owlchain.consensus.consensusProtocolDriver;
import owlchain.consensus.slot;
import owlchain.consensus.localNode;

import owlchain.utils.globalChecks;
import owlchain.utils.uniqueStruct;

alias Interval = Tuple!(uint32, "low", uint32, "high");
alias RedBlackTree !(uint32, "a < b") UInt32Set;

alias StatementPredicate = bool delegate(ref const Statement st);
alias IntervalPredicate = bool delegate(ref const Interval);

alias EnvelopePtr = RefCounted!(Envelope, RefCountedAutoInitialize.no);

static const int MAX_ADVANCE_SLOT_RECURSION = 50;

class BallotProtocol
{
private :
    Slot _slot;
    bool _heardFromQuorum;

    // state tracking members
    enum CPPhase
    {
        CP_PHASE_PREPARE,
        CP_PHASE_CONFIRM,
        CP_PHASE_EXTERNALIZE,
        CP_PHASE_NUM
    };

    // human readable names matching CPPhase
    string[CPPhase.CP_PHASE_NUM] _phaseNames;

    UniqueStruct!Ballot _currentBallot;       // b
    UniqueStruct!Ballot _prepared;            // p    
    UniqueStruct!Ballot _preparedPrime;       // p'
    UniqueStruct!Ballot _highBallot;          // h
    UniqueStruct!Ballot _commit;              // c
    Envelope[NodeID] _latestEnvelopes;  // M
    CPPhase   _phase;                   // Phi
    int _currentMessageLevel;           // number of messages triggered in one run
    EnvelopePtr _lastEnvelope;          // last envelope generated by this node
    EnvelopePtr _lastEnvelopeEmit;      // last envelope emitted by this node

public :
    this(Slot value)
    {
        _slot = value;
        _heardFromQuorum = true;
        _phase = CPPhase.CP_PHASE_PREPARE;
        _currentMessageLevel = 0;
        _phaseNames = ["PREPARE", "FINISH", "EXTERNALIZE"];
    }

    ~this()
    {
        if (!_currentBallot.isEmpty) _currentBallot.release();
        if (!_prepared.isEmpty) _prepared.release();
        if (!_preparedPrime.isEmpty) _preparedPrime.release();
        if (!_highBallot.isEmpty) _highBallot.release();
        if (!_commit.isEmpty) _commit.release();
    }

    // Process a newly received envelope for this slot and update the state of
    // the slot accordingly.
    // self: set to true when node feeds its own statements in order to
    // trigger more potential state changes
    ConsensusProtocol.EnvelopeState processEnvelope(ref const Envelope envelope, bool self)
    {
        ConsensusProtocol.EnvelopeState res = ConsensusProtocol.EnvelopeState.INVALID;
        dbgAssert(envelope.statement.slotIndex == _slot.getSlotIndex());

        const Statement * statement = &envelope.statement;
        const NodeID * nodeID = &statement.nodeID;

        if (!isStatementSane(*statement, self))
        {
            if (self)
            {
                writefln("[ERROR], ConsensusProtocol not sane statement from self, skipping   e: %s", _slot.getCP().envToStr(envelope));
            }
            return ConsensusProtocol.EnvelopeState.INVALID;
        }

        if (!isNewerStatement(*nodeID, *statement))
        {
            if (self)
            {
                writefln("[ERROR], ConsensusProtocol stale statement from self, skipping   e: %s", _slot.getCP().envToStr(envelope));
            }
            else
            {
                writefln("[TRACE], ConsensusProtocol stale statement, skipping   i: %d", _slot.getSlotIndex);
            }
            return ConsensusProtocol.EnvelopeState.INVALID;
        }

        auto validationRes = validateValues(*statement);
        if (validationRes != ConsensusProtocolDriver.ValidationLevel.kInvalidValue)
        {
            bool processed = false;

            if (_phase != CPPhase.CP_PHASE_EXTERNALIZE)
            {
                if (validationRes == ConsensusProtocolDriver.ValidationLevel.kMaybeValidValue)
                {
                    _slot.setFullyValidated(false);
                }

                recordEnvelope(envelope);
                processed = true;
                advanceSlot(*statement);
                res = ConsensusProtocol.EnvelopeState.VALID;
            }

            if (!processed)
            {
                // note: this handles also our own messages
                // in particular our final EXTERNALIZE message
                if (_phase == CPPhase.CP_PHASE_EXTERNALIZE && _commit.value == getWorkingBallot(*statement).value)
                {
                    recordEnvelope(envelope);
                    res = ConsensusProtocol.EnvelopeState.VALID;
                }
                else
                {
                    if (self)
                    {
                        writefln("[ERROR], ConsensusProtocol externalize statement with invalid value from self, skipping   e: %s", _slot.getCP().envToStr(envelope));
                    }

                    res = ConsensusProtocol.EnvelopeState.INVALID;
                }
            }
        }
        else
        {
            // If the value is not valid, we just ignore it.
            if (self)
            {
                writefln("[ERROR], ConsensusProtocol invalid value from self, skipping   e: %s", _slot.getCP().envToStr(envelope));
            }
            else
            {
                writefln("[TRACE], ConsensusProtocol invalid value  i: %d", _slot.getSlotIndex);
            }

            res = ConsensusProtocol.EnvelopeState.INVALID;
        }
        return res;
    }

    void ballotProtocolTimerExpired()
    {
        // don't abandon the ballot until we have heard from a slice
        if (_heardFromQuorum)
        {
            abandonBallot(0);
        }
        else
        {
            writefln("[DEBUG], ConsensusProtocol Waiting to hear from a slice.");
            startBallotProtocolTimer();
        }
    }

    // abandon's current ballot, move to a new ballot
    // at counter `n` (or, if n == 0, increment current counter)
    bool abandonBallot(uint32 n)
    {
        writefln("[DEBUG], ConsensusProtocol BallotProtocol.abandonBallot");
        bool res = false;
        Value v = cast(Value)_slot.getLatestCompositeCandidate();
        if (v.value.length == 0)
        {
            if (!_currentBallot.isEmpty)
            {
                v = _currentBallot.value;
            }
        }

        if (v.value.length != 0)
        {
            if (n == 0)
            {
                res = bumpState(v, true);
            }
            else
            {
                res = bumpState(v, n);
            }
        }
        return res;
    }

    // bumps the ballot based on the local state and the value passed in:
    // in prepare phase, attempts to take value
    // otherwise, no-ops
    // force: when true, always bumps the value, otherwise only bumps
    // the state if no value was prepared
    bool bumpState(ref const Value value, bool force)
    {
        uint32 n;
        if (!force && !_currentBallot.isEmpty)
        {
            return false;
        }

        Ballot newb;

        n = !_currentBallot.isEmpty ? (_currentBallot.counter + 1) : 1;

        return bumpState(value, n);
    }

    // flavor that takes the actual desired counter value
    bool bumpState(ref const Value value, uint32 n)
    {
        if (_phase != CPPhase.CP_PHASE_PREPARE && _phase != CPPhase.CP_PHASE_CONFIRM)
        {
            return false;
        }

        Ballot newb;

        newb.counter = n;

        if (_highBallot)
        {
            // can only bump the counter if we committed to something already
            newb.value = _highBallot.value;
        }
        else
        {
            newb.value = cast(Value)value;
        }

        writefln("[DEBUG], ConsensusProtocol BallotProtocol.bumpState i: %d v: %s",
            _slot.getSlotIndex(),
            _slot.getCP().ballotToStr(newb));

        bool updated = updateCurrentValue(newb);

        if (updated)
        {
            _slot.getCPDriver().startedBallotProtocol(_slot.getSlotIndex(), newb);
            emitCurrentStateStatement();
        }

        return updated;
    }

    // ** status methods

    // returns information about the local state in JSON format
    // including historical statements if available
    void dumpInfo(ref JSONValue ret)
    {
        import std.utf;

        JSONValue[string] stateObject;
        JSONValue state = stateObject;

        state.object["heard" ] = JSONValue(_heardFromQuorum);
        state.object["ballot"] = JSONValue(toUTF8(_slot.getCP().ballotToStr(*_currentBallot)));
        state.object["phase" ] = JSONValue(toUTF8(_phaseNames[_phase]));
        state.object["state" ] = JSONValue(toUTF8(getLocalState()));

        ret.object["ballotProtocol"] = state;
    }

    // returns information about the quorum for a given node
    void dumpQuorumInfo(ref JSONValue ret, ref const NodeID id, bool summary)
    {
        import std.utf;

        JSONValue[string] stateObject;
        JSONValue phase = stateObject;
        ret.object["phase"] = phase;

        // find the state of the node `id`
        Ballot * b;
        Hash qSetHash;

        if (!_latestEnvelopes.keys.canFind(id))
        {
            phase = JSONValue("unknown");
            if (id == _slot.getLocalNode().getNodeID())
            {
                qSetHash = cast(Hash)_slot.getLocalNode().getQuorumSetHash();
            }
        }
        else
        {
            const auto st = &(_latestEnvelopes[id].statement);

            switch (st.pledges.type.val)
            {
                case StatementType.CP_ST_PREPARE:
                    ret.object["phase"] = JSONValue("PREPARE");
                    b = cast(Ballot*)&(*st).pledges.prepare.ballot;
                    break;
                case StatementType.CP_ST_CONFIRM:
                    ret.object["phase"] = JSONValue("CONFIRM");
                    b = cast(Ballot*)&(*st).pledges.confirm.ballot;
                    break;
                case StatementType.CP_ST_EXTERNALIZE:
                    ret.object["phase"] = JSONValue("EXTERNALIZE");
                    b = cast(Ballot*)&(*st).pledges.externalize.commit;
                    break;
                default:
                    dbgAbort();
            }
            // use the companion set here even for externalize to capture
            // the view of the quorum set during consensus
            qSetHash = _slot.getCompanionQuorumSetHashFromStatement(*st);
        }

        int n_missing = 0, n_disagree = 0;

        int agree = 0;
        auto qSet = _slot.getCPDriver().getQSet(qSetHash);
        if (!qSet.refCountedStore.isInitialized)
        {
            ret.object["phase"] = JSONValue("expired");
            return;
        }

        if (summary)
        {
            JSONValue[string] disagreeObject;
            JSONValue disagree = disagreeObject;

            JSONValue[string] missingObject;
            JSONValue missing = missingObject;

            ret.object["disagree"] = disagree;
            ret.object["missing" ] = missing;
        } else {
            JSONValue[] disagreeArray;
            ret.object["disagree"] = disagreeArray;

            JSONValue[] missingArray;
            ret.object["missing" ] = missingArray;
        }

        LocalNode.forAllNodes(qSet, (ref const NodeID n) {
            if (!_latestEnvelopes.keys.canFind(n))
            {
                if (!summary)
                {
                    ret["missing"].array ~= JSONValue(_slot.getCPDriver().toShortString(n.publicKey));
                }
                n_missing++;
            }
            else if (areBallotsCompatible(getWorkingBallot(_latestEnvelopes[n].statement), *b))
            {
                agree++;
            }
            else
            {
                if (!summary)
                {
                    ret["disagree"].array ~= JSONValue(_slot.getCPDriver().toShortString(n.publicKey));
                }
                n_disagree++;
            }
        });

        if (summary)
        {
            ret["missing"] = JSONValue(n_missing);
            ret["disagree"] = JSONValue(n_disagree);
        }

        NodeID[] f = LocalNode.findClosestVBlocking(qSet, _latestEnvelopes, 
            (ref const Statement st) {
                return areBallotsCompatible(getWorkingBallot(st), *b);
            }, &id);

        ret.object["fail_at"] = JSONValue(cast(int)(f.length));

        if (!summary)
        {
            JSONValue[] failWithArray;
            ret.object["fail_with"] = failWithArray;

            for (int i = 0; i < f.length; i++)
            {
                ret["fail_with"].array ~= JSONValue(toUTF8(_slot.getCPDriver().toShortString(f[i].publicKey)));
            }

            JSONValue[string] valueObject;
            JSONValue value = valueObject;

            getLocalNode().toJson(qSet, value);

            ret.object["value"] = value;
        }

        ret.object["hash"] = JSONValue(toHexString(qSetHash.hash));
        ret.object["agree"] = JSONValue(agree);
    }

    // returns the hash of the QuorumSet that should be downloaded
    // with the statement.
    // note: the companion hash for an EXTERNALIZE statement does
    // not match the hash of the QSet, but the hash of commitQuorumSetHash
    static Hash getCompanionQuorumSetHashFromStatement(ref const Statement st)
    {
        Hash h;
        switch (st.pledges.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                h = cast(Hash)st.pledges.prepare.quorumSetHash;
                break;
            case StatementType.CP_ST_CONFIRM:
                h = cast(Hash)st.pledges.confirm.quorumSetHash;
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                h = cast(Hash)st.pledges.externalize.commitQuorumSetHash;
                break;
            default:
                dbgAbort();
        }
        return h;
    }

    // helper function to retrieve b for PREPARE, P for CONFIRM or
    // c for EXTERNALIZE messages
    static Ballot getWorkingBallot(ref const Statement st)
    {
        Ballot res;
        switch (st.pledges.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                res = cast(Ballot)st.pledges.prepare.ballot;
                break;
            case StatementType.CP_ST_CONFIRM:
                {
                    const con = &st.pledges.confirm;
                    res.counter = con.nCommit;
                    res.value = cast(Value)con.ballot.value;
                }
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                res = cast(Ballot)st.pledges.externalize.commit;
                break;
            default:
                dbgAbort();
        }
        return res;
    }

    EnvelopePtr getLastMessageSend() 
    {
        return _lastEnvelopeEmit;
    }

    void setStateFromEnvelope(ref const Envelope e)
    {
        if (!_currentBallot.isEmpty)
        {
            throw new Exception("Cannot set state after starting ballot protocol");
        }

        recordEnvelope(e);

        _lastEnvelope = refCounted(cast(Envelope)e);
        _lastEnvelopeEmit = _lastEnvelope;

        Ballot ballot;
        const auto pl = &e.statement.pledges;

        switch (pl.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                {
                    const auto prep = &pl.prepare;
                    const auto b = &prep.ballot;

                    bumpToBallot(*b, true);
                    if (prep.prepared.counter > 0)
                    {
                        _prepared = cast(UniqueStruct!Ballot)(new Ballot(prep.prepared.counter, cast(Value)prep.prepared.value));
                    }
                    if (prep.preparedPrime.counter > 0)
                    {
                        _preparedPrime = cast(UniqueStruct!Ballot)(new Ballot(prep.preparedPrime.counter, cast(Value)prep.preparedPrime.value));
                    }
                    if (prep.nH > 0)
                    {
                        _highBallot = cast(UniqueStruct!Ballot)(new Ballot(prep.nH, cast(Value)b.value));
                    }
                    if (prep.nC > 0)
                    {
                        _commit = cast(UniqueStruct!Ballot)(new Ballot(prep.nC, cast(Value)b.value));
                    }
                    _phase = CPPhase.CP_PHASE_PREPARE;
                }
                break;
            case StatementType.CP_ST_CONFIRM:
                {
                    const auto c = &pl.confirm;
                    const auto v = &c.ballot.value;

                    bumpToBallot(c.ballot, true);

                    _prepared = cast(UniqueStruct!Ballot)(new Ballot(c.nPrepared, cast(Value)c.ballot.value));
                    _highBallot = cast(UniqueStruct!Ballot)(new Ballot(c.nH, cast(Value)c.ballot.value));
                    _commit = cast(UniqueStruct!Ballot)(new Ballot(c.nCommit, cast(Value)c.ballot.value));
                    _phase = CPPhase.CP_PHASE_CONFIRM;
                }
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                {
                    const auto ext = &pl.externalize;
                    const auto v = &ext.commit.value;
                    ballot = Ballot(UINT32_MAX, cast(Value)ext.commit.value);
                    bumpToBallot(ballot, true);

                    _prepared = cast(UniqueStruct!Ballot)(new Ballot(UINT32_MAX, cast(Value)ext.commit.value));
                    _highBallot = cast(UniqueStruct!Ballot)(new Ballot(ext.nH, cast(Value)ext.commit.value));
                    _commit = cast(UniqueStruct!Ballot)(new Ballot(ext.commit.counter, cast(Value)ext.commit.value));
                    _phase = CPPhase.CP_PHASE_EXTERNALIZE;
                }
                break;
            default:
                dbgAbort();
        }
    }

    Envelope[] getCurrentState()
    {
        Envelope[] res;
        foreach (const NodeID n, const Envelope e; _latestEnvelopes)
        {
            // only return messages for self if the slot is fully validated
            if (!(n == _slot.getCP().getLocalNodeID()) || _slot.isFullyValidated())
            {
                res ~= cast(Envelope)e;
            }
        }
        return res;
    }

    Envelope[] getExternalizingState() 
    {
        Envelope[] res;
        if (_phase == CPPhase.CP_PHASE_EXTERNALIZE)
        {
            foreach (const NodeID n, const Envelope e; _latestEnvelopes)
            {
                if (!(n == _slot.getCP().getLocalNodeID()))
                {
                    // good approximation: statements with the value that
                    // externalized
                    // we could filter more using mConfirmedPrepared as well
                    if (areBallotsCompatible(getWorkingBallot(e.statement), *_commit))
                    {
                        res ~= cast(Envelope)e;
                    }
                }
                else if (_slot.isFullyValidated())
                {
                    // only return messages for self if the slot is fully validated
                    res ~= cast(Envelope)e;
                }
            }
        }
        return res;
    }

private:
    // attempts to make progress using the latest statement as a hint
    // calls into the various attempt* methods, emits message
    // to make progress
    void advanceSlot(ref const Statement hint)
    {
        _currentMessageLevel++;

        writefln("[DEBUG], ConsensusProtocol BallotProtocol.advanceSlot %d %s ", _currentMessageLevel, getLocalState());
        
        if (_currentMessageLevel >= MAX_ADVANCE_SLOT_RECURSION)
        {
            throw new Exception("maximum number of transitions reached in advanceSlot");
        }

        // Check if we should call `ballotDidHearFromQuorum`
        // we do this here so that we have a chance to evaluate it between
        // transitions
        // when a single message causes several
        if (!_heardFromQuorum && !_currentBallot.isEmpty)
        {
            if (LocalNode.isQuorum(
                                    getLocalNode().getQuorumSet(), 
                                    _latestEnvelopes,
                                    (ref const Statement st) {
                                        return _slot.getQuorumSetFromStatement(st);
                                    },
                                    (ref const Statement st) {
                                        bool res;
                                        if (st.pledges.type.val == StatementType.CP_ST_PREPARE)
                                        {
                                            res = _currentBallot.counter <= st.pledges.prepare.ballot.counter;
                                        }
                                        else
                                        {
                                            res = true;
                                        }
                                        return res;
                                    }))
            {
                _heardFromQuorum = true;
                _slot.getCPDriver().ballotDidHearFromQuorum(_slot.getSlotIndex(), *_currentBallot);
            }
        }

        // attempt* methods will queue up messages, causing advanceSlot to be
        // called recursively

        // done in order so that we follow the steps from the white paper in
        // order
        // allowing the state to be updated properly

        bool didWork = false;

        didWork = attemptPreparedAccept(hint) || didWork;

        didWork = attemptPreparedConfirmed(hint) || didWork;

        didWork = attemptAcceptCommit(hint) || didWork;

        didWork = attemptConfirmCommit(hint) || didWork;

        // only bump after we're done with everything else
        if (_currentMessageLevel == 1)
        {
            bool didBump = false;
            do
            {
                // attemptBump may invoke advanceSlot recursively
                didBump = attemptBump();
                didWork = didBump || didWork;
            } while (didBump);
        }

        writefln("[DEBUG], ConsensusProtocol BallotProtocol.advanceSlot %d - exiting %s ", _currentMessageLevel, getLocalState());

        --_currentMessageLevel;

        if (didWork)
        {
            sendLatestEnvelope();
        }
    }

    // returns true if all values in statement are valid
    ConsensusProtocolDriver.ValidationLevel validateValues(ref const Statement st)
    {
        ValueSet values = new ValueSet;
        switch (st.pledges.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                {
                    const auto prep = &st.pledges.prepare;
                    const auto b = &prep.ballot;
                    if (b.counter != 0)
                    {
                        values.insert(cast(Value)prep.ballot.value);
                    }
                    if (prep.prepared.counter != 0)
                    {
                        values.insert(cast(Value)prep.prepared.value);
                    }
                }
                break;
            case StatementType.CP_ST_CONFIRM:
                values.insert(cast(Value)st.pledges.confirm.ballot.value);
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                values.insert(cast(Value)st.pledges.externalize.commit.value);
                break;
            default:
                // This shouldn't happen
                return ConsensusProtocolDriver.ValidationLevel.kInvalidValue;
        }
    
        ConsensusProtocolDriver.ValidationLevel res = ConsensusProtocolDriver.ValidationLevel.kFullyValidatedValue;
        foreach (ref const Value v; values)
        {
            auto tr = _slot.getCPDriver().validateValue(_slot.getSlotIndex(), v);
            if (tr != ConsensusProtocolDriver.ValidationLevel.kFullyValidatedValue)
            {
                if (tr == ConsensusProtocolDriver.ValidationLevel.kInvalidValue)
                {
                    res = ConsensusProtocolDriver.ValidationLevel.kInvalidValue;
                }
                else
                {
                    res = ConsensusProtocolDriver.ValidationLevel.kMaybeValidValue;
                }
            }
        }
        return res;
    }

    // send latest envelope if needed
    void sendLatestEnvelope()
    {
        // emit current envelope if needed
        if (_currentMessageLevel == 0 && _lastEnvelope.refCountedStore.isInitialized && _slot.isFullyValidated())
        {
            if (!_lastEnvelopeEmit.refCountedStore.isInitialized || _lastEnvelope != _lastEnvelopeEmit)
            {
                _lastEnvelopeEmit = _lastEnvelope;
                _slot.getCPDriver().emitEnvelope(_lastEnvelopeEmit);
            }
        }
    }

    // `attempt*` methods are called by `advanceSlot` internally call the
    //  the `set*` methods.
    //   * check if the specified state for the current slot has been
    //     reached or not.
    //   * idempotent
    //  input: latest statement received (used as a hint to reduce the
    //  space to explore)
    //  output: returns true if the state was updated

    // `set*` methods progress the slot to the specified state
    //  input: state specific
    //  output: returns true if the state was updated.

    // step 1 and 5 from the CP paper
    bool attemptPreparedAccept(ref const Statement hint)
    {
        if (_phase != CPPhase.CP_PHASE_PREPARE && _phase != CPPhase.CP_PHASE_CONFIRM)
        {
            return false;
        }

        BallotSet candidates = getPrepareCandidates(hint);

        // see if we can accept any of the candidates, starting with the highest
        foreach_reverse (ref const Ballot ballot; candidates)
        {

            if (_phase == CPPhase.CP_PHASE_CONFIRM)
            {
                // only consider the ballot if it may help us increase
                // p (note: at this point, p ~ c)
                if (!areBallotsLessAndCompatible(*_prepared, ballot))
                {
                    continue;
                }
                dbgAssert(areBallotsCompatible(*_commit, ballot));
            }

            // if we already prepared this ballot, don't bother checking again

            // if ballot <= p' ballot is neither a candidate for p nor p'
            if (_preparedPrime && compareBallots(ballot, *_preparedPrime) <= 0)
            {
                continue;
            }

            if (_prepared)
            {
                // if ballot is already covered by p, skip
                if (areBallotsLessAndCompatible(ballot, *_prepared))
                {
                    continue;
                }
                // otherwise, there is a chance it increases p'
            }

            bool accepted = federatedAccept(
                // checks if any node is voting for this ballot
                (ref const Statement st) {
                    bool res;

                    switch (st.pledges.type.val)
                    {
                        case StatementType.CP_ST_PREPARE:
                            {
                                const auto p = &st.pledges.prepare;
                                res = areBallotsLessAndCompatible(ballot, p.ballot);
                            }
                            break;
                        case StatementType.CP_ST_CONFIRM:
                            {
                                const auto c = &st.pledges.confirm;
                                res = areBallotsCompatible(ballot, c.ballot);
                            }
                            break;
                        case StatementType.CP_ST_EXTERNALIZE:
                            {
                                const auto e = &st.pledges.externalize;
                                res = areBallotsCompatible(ballot, e.commit);
                            }
                            break;
                        default:
                            res = false;
                            dbgAbort();
                    }

                    return res;
                },
                (ref const Statement st) {
                    return BallotProtocol.hasPreparedBallot(ballot, st);
                }
            );
            if (accepted)
            {
                return setPreparedAccept(ballot);
            }
        }

        return false;
    }

    // prepared: ballot that should be prepared
    bool setPreparedAccept(ref const Ballot ballot)
    {
        //if (Logging::logDebug("SCP"))
       writefln("[DEBUG], ConsensusProtocol BallotProtocol.setPreparedAccept i: %d  b : %s ", _slot.getSlotIndex(), _slot.getCP().ballotToStr(ballot));

        // update our state
        bool didWork = setPrepared(ballot);

        // check if we also need to clear 'c'
        if (!_commit.isEmpty && !_highBallot.isEmpty)
        {
            if ((!_prepared.isEmpty && areBallotsLessAndIncompatible(*_highBallot, *_prepared)) ||
                (!_preparedPrime.isEmpty && areBallotsLessAndIncompatible(*_highBallot, *_preparedPrime)))
            {
                dbgAssert(_phase == CPPhase.CP_PHASE_PREPARE);
                _commit.release();
                didWork = true;
            }
        }

        if (didWork)
        {
            _slot.getCPDriver().acceptedBallotPrepared(_slot.getSlotIndex(), ballot);
            emitCurrentStateStatement();
        }

        return didWork;
    }

    // step 2+3+8 from the CP paper
    // ballot is the candidate to record as 'confirmed prepared'
    bool attemptPreparedConfirmed(ref const Statement hint)
    {
        if (_phase != CPPhase.CP_PHASE_PREPARE)
        {
            return false;
        }

        // check if we could accept this ballot as prepared
        if (_prepared.isEmpty)
        {
            return false;
        }

        BallotSet candidates1 = getPrepareCandidates(hint);
        Ballot[] candidates;
        foreach_reverse (ref Ballot ballot; candidates)
        {
            candidates ~= ballot;
        }

        // see if we can accept any of the candidates, starting with the highest
        Ballot newH;
        bool newHfound = false;
        int idx;
        for (idx = 0; idx <  candidates.length; idx++)
        {
            Ballot * ballot = &candidates[idx];
            // only consider it if we can potentially raise h
            if (!_highBallot.isEmpty && compareBallots(*_highBallot, *ballot) >= 0)
            {
                break;
            }

            bool ratified = federatedRatify((ref const Statement st){ return BallotProtocol.hasPreparedBallot(*ballot, st);});
            if (ratified)
            {
                newH = *ballot;
                newHfound = true;
                break;
            }
        }

        bool res = false;

        if (newHfound)
        {
            Ballot newC;
            // now, look for newC (left as 0 if no update)
            // step (3) from the paper
            Ballot b = !_currentBallot.isEmpty ? *_currentBallot : Ballot();
            if (
                    (_commit.isEmpty) &&
                    (_prepared.isEmpty || !areBallotsLessAndIncompatible(newH, *_prepared)) &&
                    (_preparedPrime.isEmpty || !areBallotsLessAndIncompatible(newH, *_preparedPrime))
               )
            {
                // continue where we left off (cur is at newH at this point)
                // incomplete
                //for (; cur != candidates.rend(); cur++)
                for (; idx <  candidates.length; idx++)
                {
                    Ballot * ballot = &candidates[idx];

                    if (compareBallots(*ballot, b) < 0)
                    {
                        break;
                    }
                    bool ratified = federatedRatify((ref const Statement st){ return BallotProtocol.hasPreparedBallot(*ballot, st);});
                    if (ratified)
                    {
                        newC = *ballot;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            res = setPreparedConfirmed(newC, newH);
        }
        return res;
    }

    // newC, newH : low/high bounds prepared confirmed
    bool setPreparedConfirmed(ref const Ballot newC, ref const Ballot newH)
    {
        //if (Logging::logDebug("SCP"))
        writefln("[DEBUG], ConsensusProtocol BallotProtocol.setPreparedConfirmed i: %d  h : %s ", _slot.getSlotIndex(), _slot.getCP().ballotToStr(newH));

        bool didWork = false;

        if (!_highBallot || compareBallots(newH, *_highBallot) > 0)
        {
            didWork = true;
            _highBallot = cast(UniqueStruct!Ballot)(new Ballot(newH.counter, cast(Value)newH.value));
        }

        if (newC.counter != 0)
        {
            dbgAssert(_commit.isEmpty);
            _commit = cast(UniqueStruct!Ballot)(new Ballot(newC.counter, cast(Value)newC.value));
            didWork = true;
        }

        if (didWork)
        {
            updateCurrentIfNeeded();

            _slot.getCPDriver().confirmedBallotPrepared(_slot.getSlotIndex(), newH);
            emitCurrentStateStatement();
        }
        return didWork;
    }

    // step (4 and 6)+8 from the CP paper
    bool attemptAcceptCommit(ref const Statement hint)
    {
        if (_phase != CPPhase.CP_PHASE_PREPARE && _phase != CPPhase.CP_PHASE_CONFIRM)
        {
            return false;
        }

        // extracts value from hint
        // note: ballot.counter is only used for logging purpose as we're looking at
        // possible value to commit
        Ballot ballot;
        switch (hint.pledges.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                {
                    const auto prep = &hint.pledges.prepare;
                    if (prep.nC != 0)
                    {
                        ballot = Ballot(prep.nH, cast(Value)prep.ballot.value);
                    }
                    else
                    {
                        return false;
                    }
                }
                break;
            case StatementType.CP_ST_CONFIRM:
                {
                    const auto con = &hint.pledges.confirm;
                    ballot = Ballot(con.nH, cast(Value)con.ballot.value);
                }
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                {
                    const auto ext = &hint.pledges.externalize;
                    ballot = Ballot(ext.nH, cast(Value)ext.commit.value);
                    break;
                }
            default:
                dbgAbort();
        }

        if (_phase == CPPhase.CP_PHASE_CONFIRM)
        {
            if (!areBallotsCompatible(ballot, *_highBallot))
            {
                return false;
            }
        }

        IntervalPredicate pred = (ref const Interval cur) {
            return federatedAccept  (
            (ref const Statement st) {
                bool res = false;
                const auto pl = &st.pledges;
                switch (pl.type.val)
                {
                    case StatementType.CP_ST_PREPARE:
                        {
                            const auto p = &pl.prepare;
                            if (areBallotsCompatible(ballot, p.ballot))
                            {
                                if (p.nC != 0)
                                {
                                    res = p.nC <= cur.low && cur.high <= p.nH;
                                }
                            }
                        }
                        break;
                    case StatementType.CP_ST_CONFIRM:
                        {
                            const auto c = &pl.confirm;
                            if (areBallotsCompatible(ballot, c.ballot))
                            {
                                res = c.nCommit <= cur.low;
                            }
                        }
                        break;
                    case StatementType.CP_ST_EXTERNALIZE:
                        {
                            const auto e = &pl.externalize;
                            if (areBallotsCompatible(ballot, e.commit))
                            {
                                res = e.commit.counter <= cur.low;
                            }
                        }
                        break;
                    default:
                        dbgAbort();
                }
                return res;
            },
            (ref const Statement st) {
                return BallotProtocol.commitPredicate(ballot, cur, st);
            });
        };

        // build the boundaries to scan
        UInt32Set boundaries = getCommitBoundariesFromStatements(ballot);

        if (boundaries.empty)
        {
            return false;
        }

        // now, look for the high interval
        Interval candidate;

        findExtendedInterval(candidate, boundaries, pred);

        bool res = false;

        if (candidate.low != 0)
        {
            if (_phase != CPPhase.CP_PHASE_CONFIRM || candidate.high > _highBallot.counter)
            {
                Ballot c = Ballot(candidate.low, ballot.value);
                Ballot h = Ballot(candidate.high, ballot.value);
                res = setAcceptCommit(c, h);
            }
        }
        return res;
    }

    // new values for c and h
    bool setAcceptCommit(ref const Ballot c, ref const Ballot h)
    {
        //if (Logging::logDebug("SCP"))
        writefln("[DEBUG], ConsensusProtocol BallotProtocol.setAcceptCommit i: %d  new c: %s new h: %s",
                 _slot.getSlotIndex(), _slot.getCP().ballotToStr(c), _slot.getCP().ballotToStr(h));

        bool didWork = false;

        if (_highBallot.isEmpty() || _commit.isEmpty() || compareBallots(*_highBallot, h) != 0 || compareBallots(*_commit, c) != 0)
        {
            _commit = cast(UniqueStruct!Ballot)(new Ballot(c.counter, cast(Value)c.value));
            _highBallot = cast(UniqueStruct!Ballot)(new Ballot(h.counter, cast(Value)h.value));

            didWork = true;
        }

        if (_phase == CPPhase.CP_PHASE_PREPARE)
        {
            _phase = CPPhase.CP_PHASE_CONFIRM;
            if (!_currentBallot.isEmpty && !areBallotsLessAndCompatible(h, *_currentBallot))
            {
                bumpToBallot(h, false);
            }
            _preparedPrime.release();

            didWork = true;
        }

        if (didWork)
        {
            updateCurrentIfNeeded();

            _slot.getCPDriver().acceptedCommit(_slot.getSlotIndex(), h);
            emitCurrentStateStatement();
        }
        return didWork;
    }

    // step 7+8 from the CP paper
    bool attemptConfirmCommit(ref const Statement hint)
    {
        if (_phase != CPPhase.CP_PHASE_CONFIRM)
        {
            return false;
        }

        if (_highBallot.isEmpty() || _commit.isEmpty())
        {
            return false;
        }

        // extracts value from hint
        // note: ballot.counter is only used for logging purpose
        Ballot ballot;
        switch (hint.pledges.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                {
                    return false;
                }
                //break;
            case StatementType.CP_ST_CONFIRM:
                {
                    auto con = &hint.pledges.confirm;
                    ballot = Ballot(con.nH, cast(Value)con.ballot.value);
                }
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                {
                    auto ext = &hint.pledges.externalize;
                    ballot = Ballot(ext.nH, cast(Value)ext.commit.value);
                    break;
                }
            default:
                dbgAbort();
        }

        if (!areBallotsCompatible(ballot, *_commit))
        {
            return false;
        }

        UInt32Set boundaries = getCommitBoundariesFromStatements(ballot);
        Interval candidate;

        IntervalPredicate pred = (ref const Interval cur) {
            return federatedRatify(
                                   (ref const Statement st) {
                                       return BallotProtocol.commitPredicate(ballot, cur, st);
                                   });
        };

        findExtendedInterval(candidate, boundaries, pred);

        bool res = candidate.low != 0;
        if (res)
        {
            Ballot c = Ballot(candidate.low, ballot.value);
            Ballot h = Ballot(candidate.high, ballot.value);
            return setConfirmCommit(c, h);
        }
        return res;
    }

    bool setConfirmCommit(ref const Ballot acceptCommitLow, ref const Ballot acceptCommitHigh)
    {
        //if (Logging::logDebug("SCP"))
        writefln("[DEBUG], ConsensusProtocol BallotProtocol.setConfirmCommit i: %d  new c: %s new h: %s",
                 _slot.getSlotIndex(), _slot.getCP().ballotToStr(acceptCommitLow), _slot.getCP().ballotToStr(acceptCommitHigh));

        _commit = cast(UniqueStruct!Ballot)(new Ballot(acceptCommitLow.counter, cast(Value)acceptCommitLow.value));
        _highBallot = cast(UniqueStruct!Ballot)(new Ballot(acceptCommitHigh.counter, cast(Value)acceptCommitHigh.value));
        updateCurrentIfNeeded();

        _phase = CPPhase.CP_PHASE_EXTERNALIZE;

        emitCurrentStateStatement();

        _slot.stopNomination();

        _slot.getCPDriver().valueExternalized(_slot.getSlotIndex(), _commit.value);

        return true;
    }

    // step 9 from the CP paper
    bool attemptBump()
    {
        if (_phase == CPPhase.CP_PHASE_PREPARE || _phase == CPPhase.CP_PHASE_CONFIRM)
        {
            // find all counters
            UInt32Set allCounters = new UInt32Set;
            foreach (const NodeID n, const Envelope e; _latestEnvelopes)
            {
                const auto st = &e.statement;
                switch (st.pledges.type.val)
                {
                    case StatementType.CP_ST_PREPARE:
                        {
                            const auto p = &st.pledges.prepare;
                            allCounters.insert(p.ballot.counter);
                        }
                        break;
                    case StatementType.CP_ST_CONFIRM:
                        {
                            const auto c = &st.pledges.confirm;
                            allCounters.insert(c.ballot.counter);
                        }
                        break;
                    case StatementType.CP_ST_EXTERNALIZE:
                        {
                            allCounters.insert(UINT32_MAX);
                        }
                        break;
                    default:
                        dbgAbort();
                }
            }
            uint32 targetCounter = !_currentBallot.isEmpty() ? _currentBallot.counter : 0;

            // uses 0 as a way to track if a v-blocking set is at a higher counter
            // if so, we move to that smallest counter
            allCounters.insert(targetCounter);

            // go through the counters, find the smallest not v-blocking
            foreach (uint32 n; allCounters)
            {
                if (n < targetCounter)
                {
                    break;
                }

                bool vBlocking = LocalNode.isVBlocking(
                    getLocalNode().getQuorumSet(), 
                    _latestEnvelopes,
                    (ref const Statement st) {
                        bool res;
                        const auto pl = &st.pledges;
                        if (pl.type.val == StatementType.CP_ST_PREPARE)
                        {
                            const auto p = &pl.prepare;
                            res = n < p.ballot.counter;
                        }
                        else
                        {
                            if (pl.type.val == StatementType.CP_ST_CONFIRM)
                            {
                                res = n < pl.confirm.ballot.counter;
                            }
                            else
                            {
                                res = n != UINT32_MAX;
                            }
                        }
                        return res;
                    });

                if (n == targetCounter)
                {
                    // if current counter is not behind, don't do anything
                    if (!vBlocking)
                    {
                        break;
                    }
                }
                else
                {
                    if (!vBlocking)
                    {
                        // move to n
                        return abandonBallot(n);
                    }
                }
            }
        }
        return false;
    }

    // computes a list of candidate values that may have been prepared
    BallotSet getPrepareCandidates(ref const Statement hint)
    {
        BallotSet hintBallots_ = new BallotSet;

        switch (hint.pledges.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                {
                    const auto prep = &hint.pledges.prepare;
                    hintBallots_.insert(cast(Ballot)prep.ballot);
                    if (prep.prepared.counter > 0)
                    {
                        hintBallots_.insert(cast(Ballot)prep.prepared);
                    }
                    if (prep.preparedPrime.counter > 0)
                    {
                        hintBallots_.insert(cast(Ballot)prep.preparedPrime);
                    }
                }
                break;
            case StatementType.CP_ST_CONFIRM:
                {
                    const auto con = &hint.pledges.confirm;
                    hintBallots_.insert(Ballot(con.nPrepared, cast(Value)con.ballot.value));
                    hintBallots_.insert(Ballot(UINT32_MAX, cast(Value)con.ballot.value));
                }
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                {
                    const auto ext = &hint.pledges.externalize;
                    hintBallots_.insert(Ballot(UINT32_MAX, cast(Value)ext.commit.value));
                }
                break;
            default:
                dbgAbort();
        }

        Ballot[] hintBallots;
        foreach (ref Ballot ballot; hintBallots_)
        {
            hintBallots ~= ballot;
        }

        BallotSet candidates = new BallotSet;

        while (hintBallots.length != 0)
        {
            Ballot topVote = hintBallots[hintBallots.length-1];
            hintBallots = hintBallots[0..$-1];

            const auto val = &topVote.value;

            // find candidates that may have been prepared
            foreach (const NodeID n, const Envelope e; _latestEnvelopes)
            {
                const auto st = &e.statement;
                switch (st.pledges.type.val)
                {
                    case StatementType.CP_ST_PREPARE:
                        {
                            const auto prep = &st.pledges.prepare;
                            if (areBallotsLessAndCompatible(prep.ballot, topVote))
                            {
                                candidates.insert(cast(Ballot)prep.ballot);
                            }
                            if (prep.prepared.counter > 0 &&
                                areBallotsLessAndCompatible(prep.prepared, topVote))
                            {
                                candidates.insert(cast(Ballot)prep.prepared);
                            }
                            if (prep.preparedPrime.counter > 0 &&
                                areBallotsLessAndCompatible(prep.preparedPrime, topVote))
                            {
                                candidates.insert(cast(Ballot)prep.preparedPrime);
                            }
                        }
                        break;
                    case StatementType.CP_ST_CONFIRM:
                        {
                            const auto con = &st.pledges.confirm;
                            if (areBallotsCompatible(topVote, con.ballot))
                            {
                                candidates.insert(topVote);
                                if (con.nPrepared < topVote.counter)
                                {
                                    candidates.insert(Ballot(con.nPrepared, cast(Value)(*val)));
                                }
                            }
                        }
                        break;
                    case StatementType.CP_ST_EXTERNALIZE:
                        {
                            const auto ext = &st.pledges.externalize;
                            if (areBallotsCompatible(topVote, ext.commit))
                            {
                                candidates.insert(topVote);
                            }
                        }
                        break;
                    default:
                        dbgAbort();
                }
            }
        }

        return candidates;
    }

    // helper to perform step (8) from the paper
    void updateCurrentIfNeeded()
    {
        if (_currentBallot.isEmpty || compareBallots(*_currentBallot, *_highBallot) < 0)
        {
            bumpToBallot(*_highBallot, true);
        }
    }

    // helper function to find a contiguous range 'candidate' that satisfies the
    // predicate.
    // updates 'candidate' (or leave it unchanged)
    static void findExtendedInterval(ref Interval candidate, ref const UInt32Set boundaries, IntervalPredicate pred)
    {
        // iterate through interesting boundaries, starting from the top
        foreach_reverse (uint32 b; boundaries)
        {
            Interval cur;
            if (candidate.low == 0)
            {
                // first, find the high bound
                cur = Interval(b, b);
            }
            else if (b > candidate.high) // invalid
            {
                continue;
            }
            else
            {
                cur.low = b;
                cur.high = candidate.high;
            }

            if (pred(cur))
            {
                candidate = cur;
            }
            else if (candidate.low != 0)
            {
                // could not extend further
                break;
            }
        }
    }

    // constructs the set of counters representing the
    // commit ballots compatible with the ballot
    UInt32Set getCommitBoundariesFromStatements(ref const Ballot ballot)
    {
        UInt32Set res = new UInt32Set;
        foreach (const NodeID n, const Envelope env; _latestEnvelopes)
        {
            const auto pl = &env.statement.pledges;
            switch (pl.type.val)
            {
            case StatementType.CP_ST_PREPARE:
            {
                const auto p = &pl.prepare;
                if (areBallotsCompatible(ballot, p.ballot))
                {
                    if (p.nC)
                    {
                        res.insert(p.nC);
                        res.insert(p.nH);
                    }
                }
            }
            break;
            case StatementType.CP_ST_CONFIRM:
            {
                const auto c = &pl.confirm;
                if (areBallotsCompatible(ballot, c.ballot))
                {
                    res.insert(c.nCommit);
                    res.insert(c.nH);
                }
            }
            break;
            case StatementType.CP_ST_EXTERNALIZE:
            {
                const auto e = &pl.externalize;
                if (areBallotsCompatible(ballot, e.commit))
                {
                    res.insert(e.commit.counter);
                    res.insert(e.nH);
                    res.insert(UINT32_MAX);
                }
            }
            break;
            default:
                dbgAbort();
            }
        }
        return res;
    }

    // ** helper predicates that evaluate if a statement satisfies
    // a certain property

    // is ballot prepared by st
    static bool hasPreparedBallot(ref const Ballot ballot, ref const Statement st)
    {
        bool res;

        switch (st.pledges.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                {
                    const auto p = &st.pledges.prepare;
                    res =
                        (p.prepared.counter > 0 && areBallotsLessAndCompatible(ballot, p.prepared)) ||
                        (p.preparedPrime.counter > 0 && areBallotsLessAndCompatible(ballot, p.preparedPrime));
                }
                break;
            case StatementType.CP_ST_CONFIRM:
                {
                    const auto c = &st.pledges.confirm;
                    Ballot prepared = Ballot(c.nPrepared, cast(Value)c.ballot.value);
                    res = areBallotsLessAndCompatible(ballot, prepared);
                }
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                {
                    const auto e = &st.pledges.externalize;
                    res = areBallotsCompatible(ballot, e.commit);
                }
                break;
            default:
                res = false;
                dbgAbort();
        }

        return res;
    }

    // returns true if the statement commits the ballot in the range 'check'
    static bool commitPredicate(ref const Ballot ballot, ref const Interval check, ref const Statement st)
    {
        bool res = false;
        const auto pl = &st.pledges;
        switch (pl.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                break;
            case StatementType.CP_ST_CONFIRM:
                {
                    const auto c = &pl.confirm;
                    if (areBallotsCompatible(ballot, c.ballot))
                    {
                        res = c.nCommit <= check.low && check.high <= c.nH;
                    }
                }
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                {
                    const auto e = &pl.externalize;
                    if (areBallotsCompatible(ballot, e.commit))
                    {
                        res = e.commit.counter <= check.low;
                    }
                }
                break;
            default:
                dbgAbort();
        }
        return res;
    }

    // attempts to update p to ballot (updating p' if needed)
    bool setPrepared(ref const Ballot ballot)
    {
        bool didWork = false;

        if (_prepared)
        {
            int comp = compareBallots(*_prepared, ballot);
            if (comp < 0)
            {
                if (!areBallotsCompatible(*_prepared, ballot))
                {
                    _preparedPrime = cast(UniqueStruct!Ballot)(new Ballot(_prepared.counter, cast(Value)_prepared.value));
                }
                _prepared = cast(UniqueStruct!Ballot)(new Ballot(ballot.counter, cast(Value)ballot.value));
                didWork = true;
            }
            else if (comp > 0)
            {
                // check if we should update only p'
                if (_preparedPrime.counter == 0 || compareBallots(*_preparedPrime, ballot) < 0)
                {
                    _preparedPrime = cast(UniqueStruct!Ballot)(new Ballot(ballot.counter, cast(Value)ballot.value));
                    didWork = true;
                }
            }
        }
        else
        {
            _prepared = cast(UniqueStruct!Ballot)(new Ballot(ballot.counter, cast(Value)ballot.value));
            didWork = true;
        }
        return didWork;
    }
    // ** Helper methods to compare two ballots

    // ballot comparison (ordering)
    static int compareBallots(ref const UniqueStruct!Ballot b1, ref const UniqueStruct!Ballot b2)
    {
        int res;
        if (b1 && b2)
        {
            res = compareBallots(*b1, *b2);
        }
        else if (b1 && !b2)
        {
            res = 1;
        }
        else if (!b1 && b2)
        {
            res = -1;
        }
        else
        {
            res = 0;
        }
        return res;
    }

    static int compareBallots(ref const Ballot b1, ref const Ballot b2)
    {
        if (b1.counter < b2.counter)
        {
            return -1;
        }
        else if (b2.counter < b1.counter)
        {
            return 1;
        }
        // ballots are also strictly ordered by value
        if (b1.value.value < b2.value.value)
        {
            return -1;
        }
        else if (b2.value.value < b1.value.value)
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }

    // b1 ~ b2
    static bool areBallotsCompatible(const Ballot b1, const Ballot b2)
    {
        return b1.value == b2.value;
    }

    // b1 <= b2 && b1 !~ b2
    static bool areBallotsLessAndIncompatible(ref const Ballot b1, ref const Ballot b2)
    {
        return (compareBallots(b1, b2) <= 0) && !areBallotsCompatible(b1, b2);
    }

    // b1 <= b2 && b1 ~ b2
    static bool areBallotsLessAndCompatible(ref const Ballot b1, ref const Ballot b2)
    {
        return (compareBallots(b1, b2) <= 0) && areBallotsCompatible(b1, b2);
    }

    // ** statement helper functions

    // returns true if the statement is newer than the one we know about
    // for a given node.
    bool isNewerStatement(ref const NodeID nodeID, ref const Statement st)
    {
        bool res = false;
        if (!_latestEnvelopes.keys.canFind(nodeID))
        {
            res = true;
        }
        else
        {
            res = isNewerStatement(_latestEnvelopes[nodeID].statement, st);
        }
        return res;
    }

    // returns true if st is newer than oldst
    static bool isNewerStatement(ref const Statement oldst, ref const Statement st)
    {
        bool res = false;

        // total ordering described in SCP paper.
        auto t = st.pledges.type.val;

        // statement type (PREPARE < CONFIRM < EXTERNALIZE)
        if (oldst.pledges.type.val != t)
        {
            res = (oldst.pledges.type.val < t);
        }
        else
        {
            // can't have duplicate EXTERNALIZE statements
            if (t == StatementType.CP_ST_EXTERNALIZE)
            {
                res = false;
            }
            else if (t == StatementType.CP_ST_CONFIRM)
            {
                // sorted by (b, p, p', h) (p' = 0 implicitely)
                const auto oldC = &oldst.pledges.confirm;
                const auto c = &st.pledges.confirm;
                int compBallot = compareBallots(oldC.ballot, c.ballot);
                if (compBallot < 0)
                {
                    res = true;
                }
                else if (compBallot == 0)
                {
                    if (oldC.nPrepared == c.nPrepared)
                    {
                        res = (oldC.nH < c.nH);
                    }
                    else
                    {
                        res = (oldC.nPrepared < c.nPrepared);
                    }
                }
            }
            else
            {
                // Lexicographical order between PREPARE statements:
                // (b, p, p', h)
                const auto oldPrep = &oldst.pledges.prepare;
                const auto prep = &st.pledges.prepare;

                int compBallot = compareBallots(oldPrep.ballot, prep.ballot);
                if (compBallot < 0)
                {
                    res = true;
                }
                else if (compBallot == 0)
                {
                    compBallot = compareBallots(oldPrep.prepared, prep.prepared);
                    if (compBallot < 0)
                    {
                        res = true;
                    }
                    else if (compBallot == 0)
                    {
                        compBallot = compareBallots(oldPrep.preparedPrime, prep.preparedPrime);
                        if (compBallot < 0)
                        {
                            res = true;
                        }
                        else if (compBallot == 0)
                        {
                            res = (oldPrep.nH < prep.nH);
                        }
                    }
                }
            }
        }

        return res;
    }

    // basic sanity check on statement
    static bool isStatementSane(ref const Statement st, bool self)
    {
        auto res = true;

        switch (st.pledges.type.val)
        {
            case StatementType.CP_ST_PREPARE:
            {
                const auto p = &st.pledges.prepare;
                // self is allowed to have b = 0 (as long as it never gets emitted)
                bool isOK = self || p.ballot.counter > 0;

                isOK = isOK && ((!p.preparedPrime.counter || !p.prepared.counter) || (areBallotsLessAndIncompatible(p.preparedPrime, p.prepared)));

                isOK = isOK && (p.nH == 0 || (p.prepared.counter && p.nH <= p.prepared.counter));

                // c != 0 -> c <= h <= b
                isOK = isOK && (p.nC == 0 || (p.nH != 0 && p.ballot.counter >= p.nH && p.nH >= p.nC));

                if (!isOK)
                {
                    writefln("[DEBUG], ConsensusProtocol Malformed PREPARE message");
                    res = false;
                }
            }
            break;

            case StatementType.CP_ST_CONFIRM:
            {
                const auto c = &st.pledges.confirm;
                // c <= h <= b
                res = c.ballot.counter > 0;
                res = res && (c.nH <= c.ballot.counter);
                res = res && (c.nCommit <= c.nH);
                if (!res)
                {
                    writefln("[DEBUG], ConsensusProtocol Malformed CONFIRM message");
                }
            }
            break;
            case StatementType.CP_ST_EXTERNALIZE:
            {
                const auto e = &st.pledges.externalize;

                res = e.commit.counter > 0;
                res = res && e.nH >= e.commit.counter;

                if (!res)
                {
                    writefln("[DEBUG], ConsensusProtocol Malformed EXTERNALIZE message");
                }
            }
            break;
            default:
                dbgAbort();
        }

        return res;
    }

    // records the statement in the state machine
    void recordEnvelope(ref const Envelope env)
    {
        const auto st = &env.statement;
        if (!_latestEnvelopes.keys.canFind(st.nodeID))
        {
            _latestEnvelopes[st.nodeID] = cast(Envelope)env;
        }
        else
        {
            _latestEnvelopes[st.nodeID] = cast(Envelope)env;
        }
        _slot.recordStatement(env.statement);
    }

    // ** State related methods

    // helper function that updates the current ballot
    // this is the lowest level method to update the current ballot and as
    // such doesn't do any validation
    // check: verifies that ballot is greater than old one
    void bumpToBallot(ref const Ballot ballot, bool check)
    {
        //if (Logging::logDebug("SCP"))
        writefln("[DEBUG], ConsensusProtocol BallotProtocol.bumpToBallot i: %d b: %s", _slot.getSlotIndex(), _slot.getCP().ballotToStr(ballot));

        // `bumpToBallot` should be never called once we committed.
        dbgAssert(_phase != CPPhase.CP_PHASE_EXTERNALIZE);

        if (check)
        {
            // We should move _currentBallot monotonically only
            dbgAssert(_currentBallot.isEmpty || compareBallots(ballot, *_currentBallot) >= 0);
        }

        bool gotBumped = _currentBallot.isEmpty || !(*_currentBallot == ballot);

        _currentBallot = cast(UniqueStruct!Ballot)(new Ballot(ballot.counter, cast(Value)ballot.value));

        _heardFromQuorum = false;

        if (gotBumped) startBallotProtocolTimer();
    }


    // switch the local node to the given ballot's value
    // with the assumption that the ballot is more recent than the one
    // we have.
    bool updateCurrentValue(ref const Ballot ballot)
    {
        if (_phase != CPPhase.CP_PHASE_PREPARE && _phase != CPPhase.CP_PHASE_CONFIRM)
        {
            return false;
        }

        bool updated = false;
        if (!_currentBallot)
        {
            bumpToBallot(ballot, true);
            updated = true;
        }
        else
        {
            dbgAssert(compareBallots(*_currentBallot, ballot) <= 0);

            if (_commit.counter != 0 && !areBallotsCompatible(*_commit, ballot))
            {
                return false;
            }

            int comp = compareBallots(*_currentBallot, ballot);
            if (comp < 0)
            {
                bumpToBallot(ballot, true);
                updated = true;
            }
            else if (comp > 0)
            {
                // this code probably changes with the final version
                // of the conciliator

                // this case may happen if the other nodes are not
                // following the protocol (and we end up with a smaller value)
                // not sure what is the best way to deal
                // with this situation
                writefln("[ERROR], ConsensusProtocol BallotProtocol.updateCurrentValue attempt to bump to a smaller value");
                // can't just bump to the value as we may already have
                // statements at counter+1
                return false;
            }
        }

        if (updated)
        {
            writefln("[TRACE], ConsensusProtocol BallotProtocol.updateCurrentValue updated");
        }

        checkInvariants();

        return updated;
    }

    // emits a statement reflecting the nodes' current state
    // and attempts to make progress
    void emitCurrentStateStatement()
    {
        StatementType t;

        switch (_phase)
        {
            case CPPhase.CP_PHASE_PREPARE:
                t.val = StatementType.CP_ST_PREPARE;
                break;
            case CPPhase.CP_PHASE_CONFIRM:
                t.val = StatementType.CP_ST_CONFIRM;
                break;
            case CPPhase.CP_PHASE_EXTERNALIZE:
                t.val = StatementType.CP_ST_EXTERNALIZE;
                break;
            default:
                dbgAbort();
        }

        Statement statement = createStatement(t);
        Envelope envelope = _slot.createEnvelope(statement);

        bool canEmit = (!_currentBallot.isEmpty && _currentBallot != null);

        // if we generate the same envelope, don't process it again
        // this can occur when updating h in PREPARE phase
        // as statements only keep track of h.n (but h.x could be different)
        auto lastEnv = _latestEnvelopes.keys.canFind(_slot.getCP().getLocalNodeID());

        if (!_latestEnvelopes.keys.canFind(_slot.getCP().getLocalNodeID()) || !(_latestEnvelopes[_slot.getCP().getLocalNodeID()] == envelope))
        {
            if (_slot.processEnvelope(envelope, true) == ConsensusProtocol.EnvelopeState.VALID)
            {
                if (canEmit && (!_lastEnvelope.refCountedStore.isInitialized || isNewerStatement(_lastEnvelope.statement, envelope.statement)))
                {
                    _lastEnvelope = refCounted(cast(Envelope)envelope);
                    // this will no-op if invoked from advanceSlot
                    // as advanceSlot consolidates all messages sent
                    sendLatestEnvelope();
                }
            }
            else
            {
                // there is a bug in the application if it queued up
                // a statement for itself that it considers invalid
                throw new Exception("moved to a bad state (ballot protocol)");
            }
        }
    }

    // verifies that the internal state is consistent
    void checkInvariants()
    {
        if (_currentBallot)
        {
            dbgAssert(_currentBallot.counter != 0);
        }

        if (_prepared && _preparedPrime)
        {
            dbgAssert(areBallotsLessAndIncompatible(*_preparedPrime, *_prepared));
        }

        if (_commit)
        {
            dbgAssert(!_currentBallot.isEmpty);
            dbgAssert(areBallotsLessAndCompatible(*_commit, *_highBallot));
            dbgAssert(areBallotsLessAndCompatible(*_highBallot, *_currentBallot));
        }

        switch (_phase)
        {
            case CPPhase.CP_PHASE_PREPARE:
                break;
            case CPPhase.CP_PHASE_CONFIRM:
                dbgAssert(!_commit.isEmpty);
                break;
            case CPPhase.CP_PHASE_EXTERNALIZE:
                dbgAssert(!_commit.isEmpty);
                dbgAssert(!_highBallot.isEmpty);
                break;
            default:
                dbgAbort();
        }
    }

    // create a statement of the given type using the local state
    Statement createStatement(ref const StatementType type)
    {
        Statement statement;

        checkInvariants();

        statement.pledges.type.val = type.val;
        switch (type.val)
        {
            case StatementType.CP_ST_PREPARE:
                {
                    auto p = &statement.pledges.prepare;
                    p.quorumSetHash = cast(Hash)getLocalNode().getQuorumSetHash();
                    if (!_currentBallot.isEmpty)
                    {
                        p.ballot = *_currentBallot;
                    }
                    if (!_commit.isEmpty)
                    {
                        p.nC = _commit.counter;
                    }
                    if (!_prepared.isEmpty)
                    {
                        p.prepared = *_prepared;
                    }
                    if (!_preparedPrime.isEmpty)
                    {
                        p.preparedPrime = *_preparedPrime;
                    }
                    if (!_highBallot.isEmpty)
                    {
                        p.nH = _highBallot.counter;
                    }
                }
                break;
            case StatementType.CP_ST_CONFIRM:
                {
                    auto c = &statement.pledges.confirm;
                    c.quorumSetHash = cast(Hash)getLocalNode().getQuorumSetHash();
                    dbgAssert(areBallotsLessAndCompatible(*_commit, *_highBallot));
                    c.ballot = *_currentBallot;
                    c.nPrepared = _prepared.counter;
                    c.nCommit = _commit.counter;
                    c.nH = _highBallot.counter;
                }
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                {
                    dbgAssert(areBallotsLessAndCompatible(*_commit, *_highBallot));
                    auto e = &statement.pledges.externalize;
                    e.commit = *_commit;
                    e.nH = _highBallot.counter;
                    e.commitQuorumSetHash = cast(Hash)getLocalNode().getQuorumSetHash();
                }
                break;
            default:
                dbgAbort();
        }

        return statement;
    }

    // returns a string representing the slot's state
    // used for log lines
    string getLocalState() 
    {
        import std.outbuffer;
        OutBuffer oBuffer = new OutBuffer(); 
        oBuffer.writef("i: %d | %s", _slot.getSlotIndex(), _phaseNames[_phase]);
        oBuffer.writef(" | b: %s", _slot.getCP().ballotToStr(*_currentBallot));
        oBuffer.writef(" | p: %s", _slot.getCP().ballotToStr(*_prepared));
        oBuffer.writef(" | p: %s", _slot.getCP().ballotToStr(*_preparedPrime));
        oBuffer.writef(" | h: %s", _slot.getCP().ballotToStr(*_highBallot));
        oBuffer.writef(" | c: %s", _slot.getCP().ballotToStr(*_commit));
        oBuffer.writef(" | M: %d", _latestEnvelopes.length);
        return oBuffer.toString();
    }

    LocalNode getLocalNode()
    {
        return _slot.getCP().getLocalNode();
    }

    bool federatedAccept(StatementPredicate voted, StatementPredicate accepted)
    {
        return _slot.federatedAccept(voted, accepted, _latestEnvelopes);
    }

    bool federatedRatify(StatementPredicate voted)
    {
        return _slot.federatedRatify(voted, _latestEnvelopes);
    }

    void startBallotProtocolTimer()
    {
        long timeout = _slot.getCPDriver().computeTimeout(_currentBallot.counter);
        Slot slot = _slot;
        _slot.getCPDriver().setupTimer(_slot.getSlotIndex(), Slot.BALLOT_PROTOCOL_TIMER, timeout, (){ _slot.getBallotProtocol().ballotProtocolTimerExpired(); });
    }

}