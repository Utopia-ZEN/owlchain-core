module owlchain.consensus.ballotProtocol;

import std.stdio;
import std.container;
import std.conv;
import std.json;
import std.algorithm: canFind;
import std.algorithm : find;
import std.typecons;
import std.digest.sha;
import core.stdc.stdint;

import owlchain.xdr.type;
import owlchain.xdr.statement;
import owlchain.xdr.statementType;
import owlchain.xdr.hash;
import owlchain.xdr.envelope;
import owlchain.xdr.value;
import owlchain.xdr.quorumSet;
import owlchain.xdr.nodeID;
import owlchain.xdr.ballot;

import owlchain.consensus.consensusProtocol;
import owlchain.consensus.consensusProtocolDriver;
import owlchain.consensus.slot;
import owlchain.consensus.localNode;

import owlchain.util.globalChecks;

alias StatementPredicate = bool delegate(ref const Statement st);

alias EnvelopePtr = RefCounted!(Envelope, RefCountedAutoInitialize.no);

static const int MAX_ADVANCE_SLOT_RECURSION = 50;

class BallotProtocol
{
private :
    Slot _slot;
    bool _heardFromQuorum;

    // state tracking members
    enum CPPhase
    {
        CP_PHASE_PREPARE,
        CP_PHASE_CONFIRM,
        CP_PHASE_EXTERNALIZE,
        CP_PHASE_NUM
    };

    // human readable names matching CPPhase
    string[CPPhase.CP_PHASE_NUM] _phaseNames;

    Unique!Ballot _currentBallot;      // b
    Unique!Ballot _prepared;           // p    
    Unique!Ballot _preparedPrime;      // p'
    Unique!Ballot _highBallot;         // h
    Unique!Ballot _commit;             // c
    Envelope[NodeID] _latestEnvelopes; // M
    CPPhase   _phase;                                // Phi

    int _currentMessageLevel; // number of messages triggered in one run

    EnvelopePtr _lastEnvelope; // last envelope generated by this node

    EnvelopePtr _lastEnvelopeEmit; // last envelope emitted by this node

public :
    this(Slot value)
    {
        _slot = value;
        _heardFromQuorum = true;
        _phase = CPPhase.CP_PHASE_PREPARE;
        _currentMessageLevel = 0;
        _phaseNames = ["PREPARE", "FINISH", "EXTERNALIZE"];
    }

    // Process a newly received envelope for this slot and update the state of
    // the slot accordingly.
    // self: set to true when node feeds its own statements in order to
    // trigger more potential state changes
    ConsensusProtocol.EnvelopeState processEnvelope(ref const Envelope envelope, bool self)
    {
        ConsensusProtocol.EnvelopeState res = ConsensusProtocol.EnvelopeState.INVALID;
        dbgAssert(envelope.statement.slotIndex == _slot.getSlotIndex());

        const Statement * statement = &envelope.statement;
        const NodeID * nodeID = &statement.nodeID;

        if (!isStatementSane(*statement, self))
        {
            if (self)
            {
                writefln("[ERROR], ConsensusProtocol not sane statement from self, skipping   e: %s", _slot.getCP().envToStr(envelope));
            }

            return ConsensusProtocol.EnvelopeState.INVALID;
        }

        if (!isNewerStatement(*nodeID, *statement))
        {
            if (self)
            {
                writefln("[ERROR], ConsensusProtocol stale statement from self, skipping   e: %s", _slot.getCP().envToStr(envelope));
            }
            else
            {
                writefln("[TRACE], ConsensusProtocol stale statement, skipping   i: %d", _slot.getSlotIndex);
            }

            return ConsensusProtocol.EnvelopeState.INVALID;
        }

        auto validationRes = validateValues(*statement);
        if (validationRes != ConsensusProtocolDriver.ValidationLevel.kInvalidValue)
        {
            bool processed = false;

            if (_phase != CPPhase.CP_PHASE_EXTERNALIZE)
            {
                if (validationRes == ConsensusProtocolDriver.ValidationLevel.kMaybeValidValue)
                {
                    _slot.setFullyValidated(false);
                }

                recordEnvelope(envelope);
                processed = true;
                advanceSlot(*statement);
                res = ConsensusProtocol.EnvelopeState.VALID;
            }

            if (!processed)
            {
                // note: this handles also our own messages
                // in particular our final EXTERNALIZE message
                if (_phase == CPPhase.CP_PHASE_EXTERNALIZE && _commit.value == getWorkingBallot(*statement).value)
                {
                    recordEnvelope(envelope);
                    res = ConsensusProtocol.EnvelopeState.VALID;
                }
                else
                {
                    if (self)
                    {
                        writefln("[ERROR], ConsensusProtocol externalize statement with invalid value from self, skipping   e: %s", _slot.getCP().envToStr(envelope));
                    }

                    res = ConsensusProtocol.EnvelopeState.INVALID;
                }
            }
        }
        else
        {
            // If the value is not valid, we just ignore it.
            if (self)
            {
                writefln("[ERROR], ConsensusProtocol invalid value from self, skipping   e: %s", _slot.getCP().envToStr(envelope));
            }
            else
            {
                writefln("[TRACE], ConsensusProtocol invalid value  i: %d", _slot.getSlotIndex);
            }

            res = ConsensusProtocol.EnvelopeState.INVALID;
        }
        return res;
    }

    void ballotProtocolTimerExpired()
    {
        // don't abandon the ballot until we have heard from a slice
        if (_heardFromQuorum)
        {
            abandonBallot(0);
        }
        else
        {
            writefln("[DEBUG], ConsensusProtocol Waiting to hear from a slice.");
            startBallotProtocolTimer();
        }
    }

    // abandon's current ballot, move to a new ballot
    // at counter `n` (or, if n == 0, increment current counter)
    bool abandonBallot(uint32 n)
    {
        writefln("[DEBUG], ConsensusProtocol BallotProtocol.abandonBallot");
        bool res = false;
        Value v = cast(Value)_slot.getLatestCompositeCandidate();
        if (v.value.length == 0)
        {
            if (!_currentBallot.isEmpty)
            {
                v = _currentBallot.value;
            }
        }
        if (v.value.length != 0)
        {
            if (n == 0)
            {
                res = bumpState(v, true);
            }
            else
            {
                res = bumpState(v, n);
            }
        }
        return res;
    }

    // bumps the ballot based on the local state and the value passed in:
    // in prepare phase, attempts to take value
    // otherwise, no-ops
    // force: when true, always bumps the value, otherwise only bumps
    // the state if no value was prepared
    bool bumpState(ref const Value value, bool force)
    {
        uint32 n;
        if (!force && !_currentBallot.isEmpty)
        {
            return false;
        }

        Ballot newb;

        n = !_currentBallot.isEmpty ? (_currentBallot.counter + 1) : 1;

        return bumpState(value, n);
    }

    // flavor that takes the actual desired counter value
    bool bumpState(ref const Value value, uint32 n)
    {
        if (_phase != CPPhase.CP_PHASE_PREPARE && _phase != CPPhase.CP_PHASE_CONFIRM)
        {
            return false;
        }

        Ballot newb;

        newb.counter = n;

        if (_highBallot)
        {
            // can only bump the counter if we committed to something already
            newb.value = _highBallot.value;
        }
        else
        {
            newb.value = cast(Value)value;
        }

        writefln("[DEBUG], ConsensusProtocol BallotProtocol::bumpState i: %d v: %s",
            _slot.getSlotIndex(),
            _slot.getCP().ballotToStr(newb));

        bool updated = updateCurrentValue(newb);

        if (updated)
        {
            _slot.getCPDriver().startedBallotProtocol(_slot.getSlotIndex(), newb);
            emitCurrentStateStatement();
        }

        return updated;
    }

    // ** status methods

    // returns information about the local state in JSON format
    // including historical statements if available
    void dumpInfo(ref JSONValue ret)
    {
        import std.utf;

        JSONValue[string] stateObject;
        JSONValue state = stateObject;

        state.object["heard" ] = JSONValue(_heardFromQuorum);
        Ballot * b = cast(Ballot *)_currentBallot;
        state.object["ballot"] = JSONValue(toUTF8(_slot.getCP().ballotToStr(b)));
        state.object["phase" ] = JSONValue(toUTF8(_phaseNames[_phase]));
        state.object["state" ] = JSONValue(toUTF8(getLocalState()));

        ret.object["ballotProtocol"] = state;
    }

    // returns information about the quorum for a given node
    void dumpQuorumInfo(ref JSONValue ret, ref const NodeID id, bool summary)
    {
        import std.utf;

        JSONValue[string] stateObject;
        JSONValue phase = stateObject;
        ret.object["phase"] = phase;

        // find the state of the node `id`
        Ballot * b;
        Hash qSetHash;

        if (!_latestEnvelopes.keys.canFind(id))
        {
            phase = JSONValue("unknown");
            if (id == _slot.getLocalNode().getNodeID())
            {
                qSetHash = cast(Hash)_slot.getLocalNode().getQuorumSetHash();
            }
        }
        else
        {
            auto const st = &(_latestEnvelopes[id].statement);

            switch (st.pledges.type.val)
            {
                case StatementType.CP_ST_PREPARE:
                    ret.object["phase"] = JSONValue("PREPARE");
                    b = cast(Ballot*)&(*st).pledges.prepare.ballot;
                    break;
                case StatementType.CP_ST_CONFIRM:
                    ret.object["phase"] = JSONValue("CONFIRM");
                    b = cast(Ballot*)&(*st).pledges.confirm.ballot;
                    break;
                case StatementType.CP_ST_EXTERNALIZE:
                    ret.object["phase"] = JSONValue("EXTERNALIZE");
                    b = cast(Ballot*)&(*st).pledges.externalize.commit;
                    break;
                default:
                    dbgAbort();
            }
            // use the companion set here even for externalize to capture
            // the view of the quorum set during consensus
            qSetHash = _slot.getCompanionQuorumSetHashFromStatement(*st);
        }

        int n_missing = 0, n_disagree = 0;

        int agree = 0;
        auto qSet = _slot.getCPDriver().getQSet(qSetHash);
        if (!qSet.refCountedStore.isInitialized)
        {
            ret.object["phase"] = JSONValue("expired");
            return;
        }

        if (summary)
        {
            JSONValue[string] disagreeObject;
            JSONValue disagree = disagreeObject;

            JSONValue[string] missingObject;
            JSONValue missing = missingObject;

            ret.object["disagree"] = disagree;
            ret.object["missing" ] = missing;
        } else {
            JSONValue[] disagreeArray;
            ret.object["disagree"] = disagreeArray;

            JSONValue[] missingArray;
            ret.object["missing" ] = missingArray;
        }

        LocalNode.forAllNodes(qSet, (ref const NodeID n) {
            if (!_latestEnvelopes.keys.canFind(n))
            {
                if (!summary)
                {
                    ret["missing"].array ~= JSONValue(_slot.getCPDriver().toShortString(n.publicKey));
                }
                n_missing++;
            }
            else if (areBallotsCompatible(getWorkingBallot(_latestEnvelopes[n].statement), *b))
            {
                agree++;
            }
            else
            {
                if (!summary)
                {
                    ret["disagree"].array ~= JSONValue(_slot.getCPDriver().toShortString(n.publicKey));
                }
                n_disagree++;
            }
        });

        if (summary)
        {
            ret["missing"] = JSONValue(n_missing);
            ret["disagree"] = JSONValue(n_disagree);
        }

        NodeID[] f = LocalNode.findClosestVBlocking(qSet, _latestEnvelopes, 
            (ref const Statement st) {
                return areBallotsCompatible(getWorkingBallot(st), *b);
            }, &id);

        ret.object["fail_at"] = JSONValue(cast(int)(f.length));

        if (!summary)
        {
            JSONValue[] failWithArray;
            ret.object["fail_with"] = failWithArray;

            for (int i = 0; i < f.length; i++)
            {
                ret["fail_with"].array ~= JSONValue(toUTF8(_slot.getCPDriver().toShortString(f[i].publicKey)));
            }

            JSONValue[string] valueObject;
            JSONValue value = valueObject;

            getLocalNode().toJson(qSet, value);

            ret.object["value"] = value;
        }

        ret.object["hash"] = JSONValue(toHexString(qSetHash.hash));
        ret.object["agree"] = JSONValue(agree);
    }

    // returns the hash of the QuorumSet that should be downloaded
    // with the statement.
    // note: the companion hash for an EXTERNALIZE statement does
    // not match the hash of the QSet, but the hash of commitQuorumSetHash
    static Hash getCompanionQuorumSetHashFromStatement(ref const Statement st)
    {
        Hash h;
        switch (st.pledges.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                h = cast(Hash)st.pledges.prepare.quorumSetHash;
                break;
            case StatementType.CP_ST_CONFIRM:
                h = cast(Hash)st.pledges.confirm.quorumSetHash;
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                h = cast(Hash)st.pledges.externalize.commitQuorumSetHash;
                break;
            default:
                dbgAbort();
        }
        return h;
    }

    // helper function to retrieve b for PREPARE, P for CONFIRM or
    // c for EXTERNALIZE messages
    static Ballot getWorkingBallot(ref const Statement st)
    {
        Ballot res;
        switch (st.pledges.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                res = cast(Ballot)st.pledges.prepare.ballot;
                break;
            case StatementType.CP_ST_CONFIRM:
                {
                    const con = &st.pledges.confirm;
                    res.counter = con.nCommit;
                    res.value = cast(Value)con.ballot.value;
                }
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                res = cast(Ballot)st.pledges.externalize.commit;
                break;
            default:
                dbgAbort();
        }
        return res;
    }

    EnvelopePtr getLastMessageSend() 
    {
        return _lastEnvelopeEmit;
    }

    void setStateFromEnvelope(ref const Envelope e)
    {
        if (!_currentBallot.isEmpty)
        {
            throw new Exception("Cannot set state after starting ballot protocol");
        }

        recordEnvelope(e);

        _lastEnvelope = refCounted(cast(Envelope)e);
        _lastEnvelopeEmit = _lastEnvelope;

        Ballot ballot;
        auto const pl = &e.statement.pledges;

        switch (pl.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                {
                    auto const prep = &pl.prepare;
                    auto const b = &prep.ballot;

                    bumpToBallot(*b, true);
                    if (prep.prepared.counter > 0)
                    {
                        _prepared = cast(Unique!Ballot)(cast(Ballot*)(&prep.prepared));
                    }
                    if (prep.preparedPrime.counter > 0)
                    {
                        _preparedPrime = cast(Unique!Ballot)(cast(Ballot*)(&prep.preparedPrime));
                    }
                    if (prep.nH > 0)
                    {
                        ballot = Ballot(cast(uint32)prep.nH, cast(Value)b.value);
                        _highBallot = cast(Unique!Ballot)(&ballot);
                    }
                    if (prep.nC > 0)
                    {
                        ballot = Ballot(cast(uint32)prep.nC, cast(Value)b.value);
                        _commit = cast(Unique!Ballot)(&ballot);
                    }
                    _phase = CPPhase.CP_PHASE_PREPARE;
                }
                break;
            case StatementType.CP_ST_CONFIRM:
                {
                    auto const c = &pl.confirm;
                    auto const v = &c.ballot.value;

                    bumpToBallot(c.ballot, true);

                    ballot = Ballot(cast(uint32)c.nPrepared, cast(Value)c.ballot.value);
                    _prepared = cast(Unique!Ballot)(&ballot);

                    ballot = Ballot(cast(uint32)c.nH, cast(Value)c.ballot.value);
                    _highBallot = cast(Unique!Ballot)(&ballot);

                    ballot = Ballot(cast(uint32)c.nCommit, cast(Value)c.ballot.value);
                    _commit = cast(Unique!Ballot)(&ballot);

                    _phase = CPPhase.CP_PHASE_CONFIRM;
                }
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                {
                    auto const ext = &pl.externalize;
                    auto const v = &ext.commit.value;
                    ballot = Ballot(cast(uint32)UINT32_MAX, cast(Value)ext.commit.value);
                    bumpToBallot(ballot, true);

                    ballot = Ballot(cast(uint32)UINT32_MAX, cast(Value)ext.commit.value);
                    _prepared = cast(Unique!Ballot)(&ballot);

                    ballot = Ballot(cast(uint32)ext.nH, cast(Value)ext.commit.value);
                    _highBallot = cast(Unique!Ballot)(&ballot);

                    _commit = cast(Unique!Ballot)(cast(Ballot*)(&ext.commit));
                    _phase = CPPhase.CP_PHASE_EXTERNALIZE;
                }
                break;
            default:
                dbgAbort();
        }
    }

    Envelope[] getCurrentState()
    {
        Envelope[] res;
        foreach (const NodeID n, const Envelope e; _latestEnvelopes)
        {
            // only return messages for self if the slot is fully validated
            if (!(n == _slot.getCP().getLocalNodeID()) || _slot.isFullyValidated())
            {
                res ~= cast(Envelope)e;
            }
        }
        return res;
    }

    Envelope[] getExternalizingState() 
    {
        Envelope[] res;
        if (_phase == CPPhase.CP_PHASE_EXTERNALIZE)
        {
            foreach (const NodeID n, const Envelope e; _latestEnvelopes)
            {
                if (!(n == _slot.getCP().getLocalNodeID()))
                {
                    // good approximation: statements with the value that
                    // externalized
                    // we could filter more using mConfirmedPrepared as well
                    if (areBallotsCompatible(getWorkingBallot(e.statement), *_commit))
                    {
                        res ~= cast(Envelope)e;
                    }
                }
                else if (_slot.isFullyValidated())
                {
                    // only return messages for self if the slot is fully validated
                    res ~= cast(Envelope)e;
                }
            }
        }
        return res;
    }

private:
    // attempts to make progress using the latest statement as a hint
    // calls into the various attempt* methods, emits message
    // to make progress
    void advanceSlot(ref const Statement hint)
    {
        _currentMessageLevel++;

        writefln("[DEBUG], ConsensusProtocol BallotProtocol.advanceSlot %d %s ", _currentMessageLevel, getLocalState());
        
        if (_currentMessageLevel >= MAX_ADVANCE_SLOT_RECURSION)
        {
            throw new Exception("maximum number of transitions reached in advanceSlot");
        }

        // Check if we should call `ballotDidHearFromQuorum`
        // we do this here so that we have a chance to evaluate it between
        // transitions
        // when a single message causes several
        if (!_heardFromQuorum && !_currentBallot.isEmpty)
        {
            if (LocalNode.isQuorum(
                                    getLocalNode().getQuorumSet(), 
                                    _latestEnvelopes,
                                    (ref const Statement st) {
                                        return _slot.getQuorumSetFromStatement(st);
                                    },
                                    (ref const Statement st) {
                                        bool res;
                                        if (st.pledges.type.val == StatementType.CP_ST_PREPARE)
                                        {
                                            res = _currentBallot.counter <= st.pledges.prepare.ballot.counter;
                                        }
                                        else
                                        {
                                            res = true;
                                        }
                                        return res;
                                    }))
            {
                _heardFromQuorum = true;
                _slot.getCPDriver().ballotDidHearFromQuorum(_slot.getSlotIndex(), _currentBallot);
            }
        }

        // attempt* methods will queue up messages, causing advanceSlot to be
        // called recursively

        // done in order so that we follow the steps from the white paper in
        // order
        // allowing the state to be updated properly

        bool didWork = false;

        didWork = attemptPreparedAccept(hint) || didWork;

        didWork = attemptPreparedConfirmed(hint) || didWork;

        didWork = attemptAcceptCommit(hint) || didWork;

        didWork = attemptConfirmCommit(hint) || didWork;

        // only bump after we're done with everything else
        if (_currentMessageLevel == 1)
        {
            bool didBump = false;
            do
            {
                // attemptBump may invoke advanceSlot recursively
                didBump = attemptBump();
                didWork = didBump || didWork;
            } while (didBump);
        }

        writefln("[DEBUG], ConsensusProtocol BallotProtocol.advanceSlot %d - exiting %s ", _currentMessageLevel, getLocalState());

        --_currentMessageLevel;

        if (didWork)
        {
            sendLatestEnvelope();
        }
    }

    // returns true if all values in statement are valid
    ConsensusProtocolDriver.ValidationLevel validateValues(ref const Statement st)
    {
        ValueSet values = new ValueSet;
        switch (st.pledges.type.val)
        {
            case StatementType.CP_ST_PREPARE:
                {
                    const auto prep = &st.pledges.prepare;
                    const auto b = &prep.ballot;
                    if (b.counter != 0)
                    {
                        values.insert(cast(Value)prep.ballot.value);
                    }
                    if (prep.prepared.counter != 0)
                    {
                        values.insert(cast(Value)prep.prepared.value);
                    }
                }
                break;
            case StatementType.CP_ST_CONFIRM:
                values.insert(cast(Value)st.pledges.confirm.ballot.value);
                break;
            case StatementType.CP_ST_EXTERNALIZE:
                values.insert(cast(Value)st.pledges.externalize.commit.value);
                break;
            default:
                // This shouldn't happen
                return ConsensusProtocolDriver.ValidationLevel.kInvalidValue;
        }
    
        ConsensusProtocolDriver.ValidationLevel res = ConsensusProtocolDriver.ValidationLevel.kFullyValidatedValue;
        foreach (ref const Value v; values)
        {
            auto tr = _slot.getCPDriver().validateValue(_slot.getSlotIndex(), v);
            if (tr != ConsensusProtocolDriver.ValidationLevel.kFullyValidatedValue)
            {
                if (tr == ConsensusProtocolDriver.ValidationLevel.kInvalidValue)
                {
                    res = ConsensusProtocolDriver.ValidationLevel.kInvalidValue;
                }
                else
                {
                    res = ConsensusProtocolDriver.ValidationLevel.kMaybeValidValue;
                }
            }
        }
        return res;
    }

    // send latest envelope if needed
    void sendLatestEnvelope()
    {
        // emit current envelope if needed
        if (_currentMessageLevel == 0 && _lastEnvelope.refCountedStore.isInitialized && _slot.isFullyValidated())
        {
            if (!_lastEnvelopeEmit.refCountedStore.isInitialized || _lastEnvelope != _lastEnvelopeEmit)
            {
                _lastEnvelopeEmit = _lastEnvelope;
                _slot.getCPDriver().emitEnvelope(_lastEnvelopeEmit);
            }
        }
    }

    // `attempt*` methods are called by `advanceSlot` internally call the
    //  the `set*` methods.
    //   * check if the specified state for the current slot has been
    //     reached or not.
    //   * idempotent
    //  input: latest statement received (used as a hint to reduce the
    //  space to explore)
    //  output: returns true if the state was updated

    // `set*` methods progress the slot to the specified state
    //  input: state specific
    //  output: returns true if the state was updated.

    // step 1 and 5 from the CP paper
    bool attemptPreparedAccept(ref const Statement hint)
    {
        if (_phase != CPPhase.CP_PHASE_PREPARE && _phase != CPPhase.CP_PHASE_CONFIRM)
        {
            return false;
        }

        BallotSet candidates = getPrepareCandidates(hint);

        // see if we can accept any of the candidates, starting with the highest
        foreach_reverse (ref const Ballot ballot; candidates)
        {

            if (_phase == CPPhase.CP_PHASE_CONFIRM)
            {
                // only consider the ballot if it may help us increase
                // p (note: at this point, p ~ c)
                if (!areBallotsLessAndCompatible(*_prepared, ballot))
                {
                    continue;
                }
                dbgAssert(areBallotsCompatible(*_commit, ballot));
            }

            // if we already prepared this ballot, don't bother checking again

            // if ballot <= p' ballot is neither a candidate for p nor p'
            if (_preparedPrime && compareBallots(ballot, *_preparedPrime) <= 0)
            {
                continue;
            }

            if (_prepared)
            {
                // if ballot is already covered by p, skip
                if (areBallotsLessAndCompatible(ballot, *_prepared))
                {
                    continue;
                }
                // otherwise, there is a chance it increases p'
            }

            bool accepted = federatedAccept(
                // checks if any node is voting for this ballot
                (ref const Statement st) {
                    bool res;

                    switch (st.pledges.type.val)
                    {
                        case StatementType.CP_ST_PREPARE:
                            {
                                const auto p = &st.pledges.prepare;
                                res = areBallotsLessAndCompatible(ballot, p.ballot);
                            }
                            break;
                        case StatementType.CP_ST_CONFIRM:
                            {
                                const auto c = &st.pledges.confirm;
                                res = areBallotsCompatible(ballot, c.ballot);
                            }
                            break;
                        case StatementType.CP_ST_EXTERNALIZE:
                            {
                                const auto e = &st.pledges.externalize;
                                res = areBallotsCompatible(ballot, e.commit);
                            }
                            break;
                        default:
                            res = false;
                            dbgAbort();
                    }

                    return res;
                },
                (ref const Statement st) {
                    return BallotProtocol.hasPreparedBallot(ballot, st);
                }
            );
            if (accepted)
            {
                return setPreparedAccept(ballot);
            }
        }

        return false;
    }

    // prepared: ballot that should be prepared
    bool setPreparedAccept(ref const Ballot prepared)
    {
       /*
        //if (Logging::logDebug("SCP"))
        writefln("[DEBUG], ConsensusProtocol BallotProtocol.setPreparedAccept i: %d  b : %s ", _slot.getSlotIndex(), _slot.getCP().ballotToStr(ballot));

        // update our state
        bool didWork = setPrepared(ballot);

        // check if we also need to clear 'c'
        if (!_commit.isEmpty && !_highBallot.isEmpty)
        {
            if ((!_prepared.isEmpty && areBallotsLessAndIncompatible(*_highBallot, *_prepared)) ||
                (!_preparedPrime.isEmpty && areBallotsLessAndIncompatible(*_highBallot, *_preparedPrime)))
            {
                dbgAssert(mPhase == SCP_PHASE_PREPARE);
                mCommit.reset();
                didWork = true;
            }
        }

        if (didWork)
        {
            mSlot.getSCPDriver().acceptedBallotPrepared(mSlot.getSlotIndex(),
                                                        ballot);
            emitCurrentStateStatement();
        }

        return didWork;
        */
        return false;
    }

    // step 2+3+8 from the CP paper
    // ballot is the candidate to record as 'confirmed prepared'
    bool attemptPreparedConfirmed(ref const Statement hint)
    {
        // incomplete
        return false;
    }

    // newC, newH : low/high bounds prepared confirmed
    bool setPreparedConfirmed(ref const Ballot newC, ref const Ballot newH)
    {
        // incomplete
        return false;
    }

    // step (4 and 6)+8 from the CP paper
    bool attemptAcceptCommit(ref const Statement hint)
    {
        // incomplete
        return false;
    }

    // new values for c and h
    bool setAcceptCommit(ref const Ballot c, ref const Ballot h)
    {
        // incomplete
        return false;
    }

    // step 7+8 from the CP paper
    bool attemptConfirmCommit(ref const Statement hint)
    {
        // incomplete
        return false;
    }

    bool setConfirmCommit(ref const Ballot acceptCommitLow, ref const Ballot acceptCommitHigh)
    {
        // incomplete
        return false;
    }

    // step 9 from the CP paper
    bool attemptBump()
    {
        // incomplete
        return false;
    }

    // computes a list of candidate values that may have been prepared
    BallotSet getPrepareCandidates(ref const Statement hint)
    {
        // incomplete
        BallotSet res = new BallotSet;
        return res;
    }

    // helper to perform step (8) from the paper
    void updateCurrentIfNeeded()
    {
        // incomplete
    }

    // An interval is [low,high] represented as a pair
    //using Interval = std::pair<uint32, uint32>;

    // helper function to find a contiguous range 'candidate' that satisfies the
    // predicate.
    // updates 'candidate' (or leave it unchanged)
    //static void findExtendedInterval(Interval& candidate,
    //                                 std::set<uint32> const& boundaries,
    //                                 std::function<bool(Interval const&)> pred);

    // constructs the set of counters representing the
    // commit ballots compatible with the ballot
    uint32[] getCommitBoundariesFromStatements(ref const Ballot ballot)
    {
        // incomplete
        uint32[] res;
        return res;
    }

    // ** helper predicates that evaluate if a statement satisfies
    // a certain property

    // is ballot prepared by st
    static bool hasPreparedBallot(ref const Ballot ballot, ref const Statement st)
    {
        // incomplete
        return false;
    }

    // returns true if the statement commits the ballot in the range 'check'
    //static bool commitPredicate(ref const Ballot ballot, Interval const& check, ref const Statement st)
    //{
    // incomplete
    //}

    // attempts to update p to ballot (updating p' if needed)
    bool setPrepared(ref const Ballot ballot)
    {
        // incomplete
        return false;
    }

    // ** Helper methods to compare two ballots

    // ballot comparison (ordering)
    static int compareBallots(ref const Unique!Ballot b1, ref const Unique!Ballot b2)
    {
        return 0;
    }

    static int compareBallots(ref const Ballot b1, ref const Ballot b2)
    {
        return 0;
    }

    // b1 ~ b2
    static bool areBallotsCompatible(const Ballot b1, const Ballot b2)
    {
        // incomplete
        return false;
    }

    // b1 <= b2 && b1 !~ b2
    static bool areBallotsLessAndIncompatible(ref const Ballot b1, ref const Ballot b2)
    {
        // incomplete
        return false;
    }

    // b1 <= b2 && b1 ~ b2
    static bool areBallotsLessAndCompatible(ref const Ballot b1, ref const Ballot b2)
    {
        // incomplete
        return false;
    }

    // ** statement helper functions

    // returns true if the statement is newer than the one we know about
    // for a given node.
    bool isNewerStatement(ref const NodeID nodeID, ref const Statement st)
    {
        // incomplete
        return false;
    }

    // returns true if st is newer than oldst
    static bool isNewerStatement(ref const Statement oldst, ref const Statement st)
    {
        // incomplete
        return false;
    }

    // basic sanity check on statement
    static bool isStatementSane(ref const Statement st, bool self)
    {
        // incomplete
        return false;
    }

    // records the statement in the state machine
    void recordEnvelope(ref const Envelope env)
    {
        // incomplete
    }

    // ** State related methods

    // helper function that updates the current ballot
    // this is the lowest level method to update the current ballot and as
    // such doesn't do any validation
    // check: verifies that ballot is greater than old one
    void bumpToBallot(ref const Ballot ballot, bool check)
    {
        // incomplete
    }

    void bumpToBallot(const Ballot ballot, bool check)
    {
        // incomplete
    }

    // switch the local node to the given ballot's value
    // with the assumption that the ballot is more recent than the one
    // we have.
    bool updateCurrentValue(ref const Ballot ballot)
    {
        // incomplete
        return false;
    }

    // emits a statement reflecting the nodes' current state
    // and attempts to make progress
    void emitCurrentStateStatement()
    {
        // incomplete
    }

    // verifies that the internal state is consistent
    void checkInvariants()
    {
        // incomplete
    }

    // create a statement of the given type using the local state
    Statement createStatement(ref const StatementType type)
    {
        // incomplete
        Statement res;
        return res;
    }

    // returns a string representing the slot's state
    // used for log lines
    string getLocalState() 
    {
        // incomplete
        return "";
    }

    LocalNode getLocalNode()
    {
        return _slot.getCP().getLocalNode();
    }

    bool federatedAccept(StatementPredicate voted, StatementPredicate accepted)
    {
        return _slot.federatedAccept(voted, accepted, _latestEnvelopes);
    }

    bool federatedRatify(StatementPredicate voted)
    {
        return _slot.federatedRatify(voted, _latestEnvelopes);
    }

    void startBallotProtocolTimer()
    {
        long timeout = _slot.getCPDriver().computeTimeout(_currentBallot.counter);
        Slot slot = _slot;
        _slot.getCPDriver().setupTimer(_slot.getSlotIndex(), Slot.BALLOT_PROTOCOL_TIMER, timeout,
                                        (){ _slot.getBallotProtocol().ballotProtocolTimerExpired(); });
    }

}